 
Instituto Tecnológico de Costa Rica, San José
Escuela de Ingeniería en Computación
IC-3101: Arquitectura de Computadores

Profesor: Esteban Arias Méndez
Tarea 5: ASM- Fechas y Años bisiestos

Elaborado por:
Lucy Chaves 
Carlos Chacón

II Semestre, 2014

Abstract: An assembly language is a more comprehensible form of machine code is the first step towards a mnemonic representation of a program. This document contains information related to the short task number 5, which is the determination of a day and a leap year starting on a date provided by the user. For this, we made use of Zeller's congruence algorithm that calculates the day of any calendar date as well as leap algorithm that identifies the rules you must follow to be considered the year a leap year.

INTRODUCCIÓN

Un lenguaje ensamblador es una forma más comprensible del código de máquina, es el primer paso hacia una representación nemónica de un programa (Pérez, 2005).  El lenguaje de máquina está compuesto por los códigos binarios de las instrucciones que se pueden ejecutar, por tanto es un lenguaje de “unos” y “ceros”. Básicamente por esto, elaborar programas directamente en el lenguaje de máquina es complicado y tedioso, entonces para reducir el nivel de dificultad de la programación a este bajo nivel, se crearon los lenguajes ensambladores, en los cuales las instrucciones que en el lenguaje de máquina se representan por grupos de bits, son representadas por símbolos mnemotécnicos (Valdés & Pallàs, 2007).
El presente documento contiene la información relacionada con la tarea corta número 5, la cual consiste en la determinación de un día de la semana y de un año bisiesto a partir de una fecha proporcionada por el usuario. Para esto se hizo uso del algoritmo de Congruencia de Zeller que permite calcular el día de cualquier fecha del calendario, así como del algoritmo bisiesto que señala las reglas que debe cumplir el año para ser considerado un año bisiesto.
El primer algoritmo calcula el día de la semana basándose en la fórmula:
DS = (d + 5c +a + [2.6m – 0.2]+[a/4]+[c/4])(mod 7)
Donde d es el día, m es el mes, c es el número compuesto por las dos primeras cifras del año y a las dos ultimas cifras del año. Para este algoritmo los meses comienzan en marzo, no en enero y los días van de 0 a 6 comenzando en domingo, además si el mes es enero o febrero se le resta uno al año, y si el año en el siglo corresponde al cero, entonces se le resta uno al siglo (Guerrero, 2009).
El segundo algoritmo plantea que si el año es divisible entre 4 y entre 100, pero no entre 400, entonces es bisiesto.

DESCRIPCIÓN DEL PROBLEMA
Se debe realizar un programa que reciba una hilera de una fecha por parte del usuario, en formato de dígitos para los datos: día, mes y año. Para los datos recibidos el programa debe calcular a qué día de la semana corresponde dicha fecha: Lunes, Martes, Miércoles, ..., Domingo. Además, el programa debe indicar si el año de la fecha indicada es un año bisiesto o no.
La fecha ingresada debe ser un solo string y no varios datos leídos por separado, igualmente el orden esperado es día, mes y año, y el rango de fechas aceptadas debe ser a partir del año 0 y posteriores, denominados DC. 
La salida del programa indicando el día debe ser un banner en grande con el dato del día y luego un mensaje indicando si el año es bisiesto o no.
El banner debe lucir como :

L    		  U     U 	N     N  	EEEE    	SSSS
L    	  	U     U  	N N   N 	E      		S
L   		  U     U  	N  N  N 	EEE     	SSS
L    		  U     U  	N     N  	E          		S
L  L  L    U U U  	N     N  	EEEE     	SSSS

El diseño de cada letra puede cambiar, pero cada letra debe ser formada por las letras en mayúscula de la misma letra, como en el ejemplo.  Finalmente, debe almacenarse una única copia de cada letra, esto para hacer más pequeño y eficiente el programa.


IMPLEMENTACIÓN
Inicialmente el programa le solicita al usuario que ingrese una fecha, los datos ingresados son guardados en un buffer. Posteriormente, a través de un ciclo se divide el buffer en el dia, el mes y el año, guardando cada parte de la fecha en un buffer distinto. Para que los datos sean manejables se implementa un ATOI.
A partir de ahi, se realiza la comprobación de que el año sea bisiesto. Para esto simplemente se realizan tres validaciones, que consisten en divisiones normales, de las que únicamente interesa su resultado en el registro DX. Básicamente, este segmento del programa lo que hace es guardar el año en el registro BX, una vez hecho esto se divide el contenido del registro entre 4 y si el residuo (DX) es cero realiza la primera validación (en procedimiento sería la segunda).
La primera validación es igualmente una división que busca que el residuo sea cero para pasar a la segunda, en la segunda validación se sigue el mismo principio. Todas las validaciones tienen ligado un caso que las lleva a la etiqueta de responder que el año es o no bisiesto. 
Una vez hecho esto, lo siguiente es llevar acabo Algoritmo de Zeller. Primeramente, los meses deben ser congruentes con lo planteado en ese algoritmo, es decir, si es enero o febrero se deben sumar 12 meses y restar un año, luego se toman los ultimos 2 digitos del año y los primeros.
Finalmente, se aplica la fórmula indicada en la introducción de este documento, y según el resultado de la misma se determina el dia que se va a imprimir en pantalla.

CONCLUSIONES
 - El manejo de datos es sumamente importante y puede ser un poco complicado asegurar que los datos estan correctos, al no poder verificar el contenido de los registros o buffers se vuelve difícil detectar un problema.
 - A la hora de realizar divisiones, es importante saber lo que indica cada registro.
 - El uso de librerías como "io.mac" permiten desarrollar un código más compacto.
 - 
 -

REFERENCIAS 

Guerrero, H. (2009). La culpa es del programmer: Fundamentos de algoritmos y lógica de programación de computadoras por el método de resolución de problemas con implementación en Microsoft Visual C++ y Microsoft Visual Basic .NET (1era. Ed). Colombia: Universidad Antonio Nariño.
Pérez, I. (2005). Lenguaje y compiladores: teoría y ejercicios (1era. Ed.). Venezuela: Universidad Valle del Momboy.
Valés, F., Pallàs, R. (2007). Microcontroladores: Fundamentos y aplicaciones con PIC (1era. Ed). España: MARCOMBO, S.A.
